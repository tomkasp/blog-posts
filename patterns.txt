1. Template method.

You should use template method when you want to delegate some portion of the code functionality to the concrete implementation.
Let's say you have an abstract class which is a thread and has run method which is implemented inside this class.
Beside of this method you have also two other method like acquire and release.
your run implementation of the run method looks like this:

public void run(){

	acquire();
	//some stuff
	release();

}

In this case your template method is a run method an concrete implementation of the abstract class has implemetation for
acquire and release methods.

2. Factory

Factory pattern, by definition, is responsible for creating new objects. I like to think about it as a single place in my code where object production happens
(the same as it is in e.g car factory).

this is the example

public class CarFactory(){

	public enum CarType{
		SUV,
		TRUCK
	}

	private CarType carType = CarType.SUV;

	public Car makeCar(){
		if(carType == CarType.SUV){
			//build suv
		}else if(carType == CarType.TRUCK) {
			//build truck
		}
	}
}

This is of course the simplest example but right now you probably have the idea about the pattern. In next post I will try to present more advanced examples.

3. Stratagy.

It's a really easy to learn pattern. Maybe more dificult sometimes to use but in theory it's quite easy. It uses the principle of the polimorphism.
Basically first you need to create an interface or abstract class whith abstract methods. Yor interface or abstract class is the type you will use in your code
and implementation is hidden below the interface or abstract class.
Let me give you an example. Imagine that we would like to implement some set of functionality which can be run on your desktop and mobile phone.
First you need to define an abstract class which will be very general - call it PlatformStrategy

public abstract class PlatformStrategy
{

	public abstract void printMessage();

}

Next step is define specyfic implementations: PlatformStrategyMobile and PlatformStrategyDesktop which extend PlatformStrategy. As you probably noticed
both method have printMessage method but ofcourse implementation of this method is different for each platform.
In practice when you want to use it you will do something like this:

PlatformStrategy platform = new PlatformStrategyDesktop();
platform.printMessage();
Ofcourse object creation can be change to something more conditional with some if statement or you can inject is through dependency injection or even read some
file or system property and do some actions based on that.

4. Bridge pattern
Bridge pattern is a pattern which main aim is to help to structure your code in a way it is ready to add new
functionality (modules, functions) and in the same time in theory it should mitigates the risk of breaking
existing functionality. This patterns fallows open/closed principle.
Open - your code is open for the extenstions (new functionality, modules, functions)
Closed - code is closed for a modification. New changes shouldn't break down existing functionality.
This can be achieved by not so comlicated rekations beetwen objects. I will try to explain those relations.
Let's use this picture from a Design Patterns: Elements of reusable software book.
Even if you don't know uml you can read from the picture that there are few elements which works together. Let's break it into smaller pieces and explain everything
But to do it we shuld use some real example of it. I will use Socket class from a java.net package
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/net/Socket.java

Think about socket as a Abstraction from our picture. Socket class defines an API for the client
which want to use it. It contains method like open (opens a socket) and close (close the scoket) etc.
You can see that those method are high level for the Socket itself. So what about low level methods
with actual implementation? Where you can find id? Answer is pretty simple you can find them in
SocketImpl class. Socket class has a field called socketImpl http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/net/Socket.java#Socket.0impl
Which type is SocketImpl. SocketImpl in our case is a Implementator from a picture and
socketImpl is a concrete instance of it. Socket istelf is an abstract class and can't be
initialized but there are multiple classes which extends SocketImpl class and they are
ConcreteImplementator from our picture. For the socket example concrete implementators are:
PlainSocket - delegations to the native socket methods
SdpSocket - supports sdp protocol.
SocksSocketImpl - SOCKS (V4 & V5) TCP socket implementation (RFC 1928).

By default when you construct object Socket SocketImpl implementation is SocksSocketImpl but of course
it can be different it depends on your needs.

Last puzzle is a 




Opisac na podstawie Socket w Javie

Presentation:https://sway.com/7qu8H4yTdj3u8Ow8
